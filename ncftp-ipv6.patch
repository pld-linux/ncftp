diff -Nur ncftp-3.0.3.orig/config.h.in ncftp-3.0.3/config.h.in
--- ncftp-3.0.3.orig/config.h.in	Sat Apr  7 17:54:58 2001
+++ ncftp-3.0.3/config.h.in	Tue Jun 19 15:30:33 2001
@@ -136,6 +136,9 @@
 /* Define if you have the fstat64 function.  */
 #undef HAVE_FSTAT64
 
+/* Define if you have the getaddrinfo function.  */
+#undef HAVE_GETADDRINFO
+
 /* Define if you have the getcwd function.  */
 #undef HAVE_GETCWD
 
@@ -145,6 +148,9 @@
 /* Define if you have the gethostname function.  */
 #undef HAVE_GETHOSTNAME
 
+/* Define if you have the getaddrname function.  */
+#undef HAVE_GETNAMEINFO
+
 /* Define if you have the getpass function.  */
 #undef HAVE_GETPASS
 
@@ -208,6 +214,9 @@
 /* Define if you have the stat64 function.  */
 #undef HAVE_STAT64
 
+/* Define if sockaddr has sa_len member */
+#undef HAVE_SOCKADDR_SA_LEN
+
 /* Define if you have the strcasecmp function.  */
 #undef HAVE_STRCASECMP
 
@@ -315,3 +324,6 @@
 
 /* Define if you have the socket library (-lsocket).  */
 #undef HAVE_LIBSOCKET
+
+/* Define if you want IPv6 support. */
+#undef ENABLE_IPV6
diff -Nur ncftp-3.0.3.orig/configure.in ncftp-3.0.3/configure.in
--- ncftp-3.0.3.orig/configure.in	Fri Apr 13 23:27:37 2001
+++ ncftp-3.0.3/configure.in	Tue Jun 19 15:30:33 2001
@@ -191,6 +191,228 @@
 	fi
 fi
 
+AC_MSG_CHECKING([whether to enable ipv6])
+AC_ARG_ENABLE(ipv6,
+[  --enable-ipv6		Enable ipv6 (with ipv4) support
+  --disable-ipv6		Disable ipv6 support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       ipv6=no
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       AC_DEFINE(ENABLE_IPV6)
+       ipv6=yes
+       ;;
+  esac ],
+
+  AC_TRY_RUN([ /* AF_INET6 avalable check */
+#define INET6
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+  exit(0);
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+],
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(ENABLE_IPV6)
+  ipv6=yes,
+  AC_MSG_RESULT(no)
+  ipv6=no,
+  AC_MSG_RESULT(no)
+  ipv6=no
+))
+
+AC_ARG_WITH(ipv6-includes,
+[  --with-ipv6-includes=DIR Search for IPv6 header files in DIR])
+test -n "${with_ipv6_includes}" && CFLAGS="-I${with_ipv6_includes} $CFLAGS"
+AC_ARG_WITH(ipv6-libraries,
+[  --with-ipv6-libraries=DIR Search for IPv6 libraries in DIR])
+test -n "${with_ipv6_libraries}" && LDFLAGS="-L${with_ipv6_libraries} $LDFLAGS"
+AC_ARG_WITH(ipv6-libname,
+[  --with-ipv6-libname=NAME library name for IPv6])
+test -n "${with_ipv6_libname}" && LIBS="$LIBS -l${with_ipv6_libname}"
+
+AC_CHECK_FUNC(getnameinfo)
+AC_CHECK_FUNC(getaddrinfo)
+
+# check if sockaddr has sa_len member
+AC_MSG_CHECKING(if sockaddr has sa_len member)
+AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/socket.h>],
+[struct sockaddr x;
+x.sa_len = 0;],
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_SOCKADDR_SA_LEN),
+       AC_MSG_RESULT(no))
+
+AC_MSG_CHECKING([whether to enable ipv6])
+AC_ARG_ENABLE(ipv6,
+[  --enable-ipv6		Enable ipv6 (with ipv4) support
+  --disable-ipv6		Disable ipv6 support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       ipv6=no
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       AC_DEFINE(ENABLE_IPV6)
+       ipv6=yes
+       ;;
+  esac ],
+
+  AC_TRY_RUN([ /* AF_INET6 avalable check */
+#define INET6
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+  exit(0);
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+],
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(ENABLE_IPV6)
+  ipv6=yes,
+  AC_MSG_RESULT(no)
+  ipv6=no,
+  AC_MSG_RESULT(no)
+  ipv6=no
+))
+
+AC_ARG_WITH(ipv6-includes,
+[  --with-ipv6-includes=DIR Search for IPv6 header files in DIR])
+test -n "${with_ipv6_includes}" && CFLAGS="-I${with_ipv6_includes} $CFLAGS"
+AC_ARG_WITH(ipv6-libraries,
+[  --with-ipv6-libraries=DIR Search for IPv6 libraries in DIR])
+test -n "${with_ipv6_libraries}" && LDFLAGS="-L${with_ipv6_libraries} $LDFLAGS"
+AC_ARG_WITH(ipv6-libname,
+[  --with-ipv6-libname=NAME library name for IPv6])
+test -n "${with_ipv6_libname}" && LIBS="$LIBS -l${with_ipv6_libname}"
+
+AC_CHECK_FUNC(getnameinfo)
+AC_CHECK_FUNC(getaddrinfo, [
+AC_MSG_CHECKING(getaddrinfo bug)
+AC_TRY_RUN([
+#include <sys/types.h>
+#include <netdb.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+main()
+{
+  int passive, gaierr, inet4 = 0, inet6 = 0;
+  struct addrinfo hints, *ai, *aitop;
+  char straddr[INET6_ADDRSTRLEN], strport[16];
+
+  for (passive = 0; passive <= 1; passive++) {
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_flags = passive ? AI_PASSIVE : 0;
+    hints.ai_socktype = SOCK_STREAM;
+    if ((gaierr = getaddrinfo(NULL, "54321", &hints, &aitop)) != 0) {
+      (void)gai_strerror(gaierr);
+      goto bad;
+    }
+    for (ai = aitop; ai; ai = ai->ai_next) {
+      if (ai->ai_addr == NULL ||
+          ai->ai_addrlen == 0 ||
+          getnameinfo(ai->ai_addr, ai->ai_addrlen,
+                      straddr, sizeof(straddr), strport, sizeof(strport),
+                      NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
+        goto bad;
+      }
+      switch (ai->ai_family) {
+      case AF_INET:
+        if (strcmp(strport, "54321") != 0) {
+	  goto bad;
+	}
+        if (passive) {
+          if (strcmp(straddr, "0.0.0.0") != 0) {
+            goto bad;
+          }
+        } else {
+          if (strcmp(straddr, "127.0.0.1") != 0) {
+            goto bad;
+          }
+        }
+        inet4++;
+        break;
+      case AF_INET6:
+       if (strcmp(strport, "54321") != 0) {
+	  goto bad;
+       }
+       if (passive) {
+          if (strcmp(straddr, "::") != 0) {
+            goto bad;
+          }
+        } else {
+          if (strcmp(straddr, "::1") != 0) {
+            goto bad;
+          }
+        }
+        inet6++;
+        break;
+      case AF_UNSPEC:
+        goto bad;
+        break;
+      default:
+        /* another family support? */
+        break;
+      }
+    }
+  }
+
+  if (!(inet4 == 0 || inet4 == 2))
+    goto bad;
+  if (!(inet6 == 0 || inet6 == 2))
+    goto bad;
+
+  if (aitop)
+    freeaddrinfo(aitop);
+  exit(0);
+
+ bad:
+  if (aitop)
+    freeaddrinfo(aitop);
+  exit(1);
+}
+],
+AC_MSG_RESULT(good)
+buggygetaddrinfo=no,
+AC_MSG_RESULT(buggy)
+buggygetaddrinfo=yes,
+AC_MSG_RESULT(buggy)
+buggygetaddrinfo=yes)
+
+if test "$buggygetaddrinfo" = "yes"; then
+	if test "$ipv6" = "yes"; then
+		echo 'Fatal: You must get working getaddrinfo() function.'
+		echo '       or you can specify "--disable-ipv6"'.
+		exit 1
+	fi
+fi
+])
+
+# check if sockaddr has sa_len member
+AC_MSG_CHECKING(if sockaddr has sa_len member)
+AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/socket.h>],
+[struct sockaddr x;
+x.sa_len = 0;],
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_SOCKADDR_SA_LEN),
+       AC_MSG_RESULT(no))
+
 CPPFLAGS="-I$MAINDIR $CPPFLAGS"
 
 if test "$no_signals" = no ; then
diff -Nur ncftp-3.0.3.orig/libncftp/ftp.c ncftp-3.0.3/libncftp/ftp.c
--- ncftp-3.0.3.orig/libncftp/ftp.c	Sun Apr 15 19:37:13 2001
+++ ncftp-3.0.3/libncftp/ftp.c	Tue Jun 19 15:30:33 2001
@@ -43,6 +43,7 @@
 
 
 
+#ifndef ENABLE_IPV6
 /* On entry, you should have 'host' be set to a symbolic name (like
  * cse.unl.edu), or set to a numeric address (like 129.93.3.1).
  * If the function fails, it will return NULL, but if the host was
@@ -72,6 +73,7 @@
 		*ip_address = ip;
 	return (hp);
 }	/* GetHostEntry */
+#endif
 
 
 
@@ -219,9 +221,13 @@
 
 
 static int
-GetSocketAddress(const FTPCIPtr cip, int sockfd, struct sockaddr_in *saddr)
+GetSocketAddress(const FTPCIPtr cip, int sockfd, struct sockaddr *saddr)
 {
+#ifdef ENABLE_IPV6
+	int len = (int) sizeof (struct sockaddr_storage);
+#else
 	int len = (int) sizeof (struct sockaddr_in);
+#endif
 	int result = 0;
 
 	if (getsockname(sockfd, (struct sockaddr *)saddr, &len) < 0) {
@@ -354,7 +360,16 @@
 	volatile int sock2fd = -1;
 	ResponsePtr rp;
 	char **volatile curaddr;
+#ifdef ENABLE_IPV6
+	struct addrinfo hints;
+	struct addrinfo *res, *res0;
+	struct sockaddr_in *sin;
+	struct sockaddr_in6 *sin6;
+	int error;
+	char buf[NI_MAXHOST];
+#else
 	struct hostent *hp;
+#endif
 	char *volatile fhost;
 	unsigned int fport;
 #ifndef NO_SIGNALS
@@ -388,7 +403,21 @@
 	cip->cin = NULL;
 	cip->cout = NULL;
 
-	/* Make sure we use network byte-order. */
+#ifdef ENABLE_IPV6
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_flags = AI_CANONNAME;
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_protocol = IPPROTO_TCP;
+	sprintf(buf, "%d\0", fport);
+	error = getaddrinfo(fhost, buf, &hints, &res0);
+	if (error) {
+		Error(cip, kDontPerror, "%s: %s.\n", fhost, gai_strerror(error));
+		cip->errNo = kErrHostUnknown;
+		return (kErrHostUnknown);
+	}
+#else
+ 	/* Make sure we use network byte-order. */
 	fport = (unsigned int) htons((unsigned short) fport);
 
 	cip->servCtlAddr.sin_port = (unsigned short) fport;
@@ -410,6 +439,7 @@
 		cip->servCtlAddr.sin_family = hp->h_addrtype;
 		/* We'll fill in the rest of the structure below. */
 	}
+#endif
 	
 	/* After obtaining a socket, try to connect it to a remote
 	 * address.  If we didn't get a host entry, we will only have
@@ -417,6 +447,7 @@
 	 * every address in the list from the host entry.
 	 */
 
+#ifndef ENABLE_IPV6
 	if (hp == NULL) {
 		/* Since we're given a single raw address, and not a host entry,
 		 * we can only try this one address and not any other addresses
@@ -499,9 +530,19 @@
 		}
 #endif	/* NO_SIGNALS */
 	} else {
+#endif
 		/* We can try each address in the list.  We'll quit when we
 		 * run out of addresses to try or get a successful connection.
 		 */
+#ifdef ENABLE_IPV6
+		for (res = res0; res; res = res->ai_next) {
+			(void) memcpy(&cip->servCtlAddr, res->ai_addr, (size_t)res->ai_addrlen);
+			if ((sockfd = socket(cip->servCtlAddr.ss_family, SOCK_STREAM, 0)) < 0) {
+				Error(cip, kDoPerror, "Could not get a socket.\n");
+				cip->errNo = kErrNewStreamSocket;
+				return (kErrNewStreamSocket);
+			}
+#else
 		for (curaddr = hp->h_addr_list; *curaddr != NULL; curaddr++) {
 			if ((sockfd = socket(cip->servCtlAddr.sin_family, SOCK_STREAM, 0)) < 0) {
 				Error(cip, kDoPerror, "Could not get a socket.\n");
@@ -513,6 +554,8 @@
 			 * just for this purpose.
 			 */
 			(void) memcpy(&cip->servCtlAddr.sin_addr, *curaddr, (size_t) hp->h_length);
+			cip->servCtlAddr.sin_family = hp->h_addrtype;
+#endif
 
 			/* This doesn't do anything if you left these
 			 * at their defaults (zero).  Otherwise it
@@ -567,8 +610,18 @@
 				}
 				return (result);
 			} else {
+#ifdef ENABLE_IPV6
+#ifdef HAVE_SOCKADDR_SA_LEN
+				err = connect(sockfd, (struct sockaddr *) &cip->servCtlAddr,
+					      cip->servCtlAddr.ss_len);
+#else
+				err = connect(sockfd, (struct sockaddr *) &cip->servCtlAddr,
+					      SA_LEN((struct sockaddr *)&cip->servCtlAddr));
+#endif
+#else
 				err = connect(sockfd, (struct sockaddr *) &cip->servCtlAddr,
 					      (int) sizeof (cip->servCtlAddr));
+#endif
 				if (cip->connTimeout > 0) {
 					(void) alarm(0);
 					(void) signal(SIGALRM, (FTPSigProc) osigalrm);
@@ -584,7 +637,12 @@
 			sockfd = -1;
 #endif /* NO_SIGNALS */
 		}
+#ifndef ENABLE_IPV6
 	}
+#endif
+#ifdef ENABLE_IPV6
+	freeaddrinfo(res0);
+#endif
 	
 	if (err < 0) {
 		/* Could not connect.  Close up shop and go home. */
@@ -642,7 +700,7 @@
 	}
 
 	/* Get our end of the socket address for later use. */
-	if ((result = GetSocketAddress(cip, sockfd, &cip->ourCtlAddr)) < 0)
+	if ((result = GetSocketAddress(cip, sockfd, (struct sockaddr *)&cip->ourCtlAddr)) < 0)
 		goto fatal;
 
 #ifdef SO_OOBINLINE
@@ -717,6 +775,20 @@
 #endif
 #endif	/* NO_SIGNALS */
 
+#ifdef ENABLE_IPV6
+#ifdef HAVE_SOCKADDR_SA_LEN
+	getnameinfo((struct sockaddr*)&cip->servCtlAddr, cip->servCtlAddr.ss_len, buf,
+		    sizeof(buf), NULL, 0, NI_NUMERICHOST);
+#else
+	getnameinfo((struct sockaddr*)&cip->servCtlAddr, SA_LEN((struct sockaddr *)&cip->servCtlAddr), buf,
+		    sizeof(buf), NULL, 0, NI_NUMERICHOST);
+#endif
+	(void) STRNCPY(cip->ip, buf);
+	if ((res0 == NULL) || (res0->ai_canonname == NULL))
+		(void) STRNCPY(cip->actualHost, fhost);
+	else
+		(void) STRNCPY(cip->actualHost, (char *) res0->ai_canonname);
+#else
 #ifdef HAVE_INET_NTOP	/* Mostly to workaround bug in IRIX 6.5's inet_ntoa */
 	(void) memset(cip->ip, 0, sizeof(cip->ip));
 	(void) inet_ntop(AF_INET, &cip->servCtlAddr.sin_addr, cip->ip, sizeof(cip->ip) - 1);
@@ -724,9 +796,10 @@
 	(void) STRNCPY(cip->ip, inet_ntoa(cip->servCtlAddr.sin_addr));
 #endif
 	if ((hp == NULL) || (hp->h_name == NULL))
-		(void) STRNCPY(cip->actualHost, fhost);
-	else
+ 		(void) STRNCPY(cip->actualHost, fhost);
+ 	else
 		(void) STRNCPY(cip->actualHost, (char *) hp->h_name);
+#endif
 
 	/* Read the startup message from the server. */	
 	rp = InitResponse();
@@ -896,11 +969,16 @@
 
 
 static int
-SendPort(const FTPCIPtr cip, struct sockaddr_in *saddr)
+SendPort(const FTPCIPtr cip, struct sockaddr *saddr)
 {
 	char *a, *p;
 	int result;
 	ResponsePtr rp;
+	struct sockaddr_in *saddr4;
+#ifdef ENABLE_IPV6
+	struct sockaddr_in6 *saddr6;
+	char buf[INET6_ADDRSTRLEN];
+#endif
 
 	rp = InitResponse();
 	if (rp == NULL) {
@@ -909,16 +987,42 @@
 		return (cip->errNo);
 	}
 
-	/* These will point to data in network byte order. */
-	a = (char *) &saddr->sin_addr;
-	p = (char *) &saddr->sin_port;
 #define UC(x) (int) (((int) x) & 0xff)
+#ifdef ENABLE_IPV6
+	if (saddr->sa_family == AF_INET6) {
+		saddr6 = (struct sockaddr_in6 *)saddr;
+		/* These will point to data in network byte order. */
+		a = (char *) &saddr6->sin6_addr;
+		p = (char *) &saddr6->sin6_port;
+		/* Need to tell the other side which host (the address) and
+		 * which process (port) on that host to send data to.
+		 */
+		result = RCmd(cip, rp, "EPRT |2|%s|%d|",
+			      inet_ntop(AF_INET6, &saddr6->sin6_addr, buf, sizeof(buf)),
+					ntohs(saddr6->sin6_port));
+		if (result != 2) {
+			result = RCmd(cip, rp, "LPRT 6,16,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,2,%d,%d",
+				      UC(a[ 0]), UC(a[ 1]), UC(a[ 2]), UC(a[ 3]),
+				      UC(a[ 4]), UC(a[ 5]), UC(a[ 6]), UC(a[ 7]),
+				      UC(a[ 8]), UC(a[ 9]), UC(a[10]), UC(a[11]),
+				      UC(a[12]), UC(a[13]), UC(a[14]), UC(a[15]),
+				      UC(p[0]), UC(p[1]));
+		}
+	} else {
+#endif
+		saddr4 = (struct sockaddr_in *)saddr;
+		/* These will point to data in network byte order. */
+		a = (char *) &saddr4->sin_addr;
+		p = (char *) &saddr4->sin_port;
 
-	/* Need to tell the other side which host (the address) and
-	 * which process (port) on that host to send data to.
-	 */
-	result = RCmd(cip, rp, "PORT %d,%d,%d,%d,%d,%d",
-		UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+		/* Need to tell the other side which host (the address) and
+		 * which process (port) on that host to send data to.
+		 */
+		result = RCmd(cip, rp, "PORT %d,%d,%d,%d,%d,%d",
+			      UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+#ifdef ENABLE_IPV6
+	}
+#endif
 
 	if (result < 0) {
 		return (result);
@@ -936,13 +1040,18 @@
 
 
 static int
-Passive(const FTPCIPtr cip, struct sockaddr_in *saddr, int *weird)
+Passive(const FTPCIPtr cip, struct sockaddr *saddr, int *weird)
 {
 	ResponsePtr rp;
-	int i[6], j;
-	unsigned char n[6];
+	int i[18], j;
+	unsigned char n[18];
 	char *cp;
 	int result;
+	struct sockaddr_in *saddr4 = (struct sockaddr_in *)saddr;
+#ifdef ENABLE_IPV6
+	struct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)saddr;
+#endif
+	unsigned short port;
 
 	rp = InitResponse();
 	if (rp == NULL) {
@@ -951,53 +1060,159 @@
 		return (cip->errNo);
 	}
 
-	result = RCmd(cip, rp, "PASV");
-	if (result < 0)
-		goto done;
-
-	if (rp->codeType != 2) {
-		/* Didn't understand or didn't want passive port selection. */
-		cip->errNo = result = kErrPASVFailed;
-		goto done;
-	}
-
-	/* The other side returns a specification in the form of
-	 * an internet address as the first four integers (each
-	 * integer stands for 8-bits of the real 32-bit address),
-	 * and two more integers for the port (16-bit port).
-	 *
-	 * It should give us something like:
-	 * "Entering Passive Mode (129,93,33,1,10,187)", so look for
-	 * digits with sscanf() starting 24 characters down the string.
-	 */
+	result = RCmd(cip, rp, "EPSV");
+	if (result != 2)
+		goto next;
+
+	if (rp->codeType != 2)
+		goto next;
+
 	for (cp = rp->msg.first->line; ; cp++) {
 		if (*cp == '\0') {
-			Error(cip, kDontPerror, "Cannot parse PASV response: %s\n", rp->msg.first->line);
-			goto done;
+			Error(cip, kDontPerror, "Cannot parse EPSV response: %s\n", rp->msg.first->line);
+			goto next;
 		}
 		if (isdigit((int) *cp))
 			break;
 	}
+	if (sscanf(cp, "%d|", &port) != 1) {
+		Error(cip, kDontPerror, "Cannot parse EPSV response: %s\n", rp->msg.first->line);
+		goto next;
+	}
+
 
-	if (sscanf(cp, "%d,%d,%d,%d,%d,%d",
-			&i[0], &i[1], &i[2], &i[3], &i[4], &i[5]) != 6) {
-		Error(cip, kDontPerror, "Cannot parse PASV response: %s\n", rp->msg.first->line);
-		goto done;
+#ifdef ENABLE_IPV6
+	if (saddr->sa_family == AF_INET6) {
+		saddr6->sin6_addr =
+			((struct sockaddr_in6 *)&cip->servCtlAddr)->sin6_addr;
+		saddr6->sin6_port = htons(port);
+	} else {
+#endif
+		saddr4->sin_addr =
+			((struct sockaddr_in *)&cip->servCtlAddr)->sin_addr;
+		saddr4->sin_port = htons(port);
+#ifdef ENABLE_IPV6
 	}
+#endif
+	goto done;
 
-	for (j=0, *weird = 0; j<6; j++) {
-		/* Some ftp servers return bogus port octets, such as
-		 * boombox.micro.umn.edu.  Let the caller know if we got a
-		 * weird looking octet.
-		 */
-		if ((i[j] < 0) || (i[j] > 255))
-			*weird = *weird + 1;
-		n[j] = (unsigned char) (i[j] & 0xff);
+ next:
+	rp = InitResponse();
+	if (rp == NULL) {
+		Error(cip, kDontPerror, "Malloc failed.\n");
+		cip->errNo = kErrMallocFailed;
+		return (cip->errNo);
 	}
+	
+#ifdef ENABLE_IPV6
+	if (saddr->sa_family == AF_INET6) {
+		int af, hal, pal;
 
-	(void) memcpy(&saddr->sin_addr, &n[0], (size_t) 4);
-	(void) memcpy(&saddr->sin_port, &n[4], (size_t) 2);
+		result = RCmd(cip, rp, "LPSV");
+		if (result < 0)
+			goto done;
+
+		if (rp->codeType != 2) {
+			/* Didn't understand or didn't want passive port selection. */
+			cip->errNo = result = kErrPASVFailed;
+			goto done;
+		}
+
+		/* The other side returns a specification in the form of
+		 * an internet address as the first four integers (each
+		 * integer stands for 8-bits of the real 32-bit address),
+		 * and two more integers for the port (16-bit port).
+		 *
+		 * It should give us something like:
+		 * "Entering Passive Mode (129,93,33,1,10,187)", so look for
+		 * digits with sscanf() starting 24 characters down the string.
+		 */
+		for (cp = rp->msg.first->line; ; cp++) {
+			if (*cp == '\0') {
+				Error(cip, kDontPerror, "Cannot parse LPSV response: %s\n", rp->msg.first->line);
+				goto done;
+			}
+			if (isdigit((int) *cp))
+				break;
+		}
+
+		if (sscanf(cp, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+			   &af, &hal,
+			   &i[ 0], &i[ 1], &i[ 2], &i[ 3],
+			   &i[ 4], &i[ 5], &i[ 6], &i[ 7],
+			   &i[ 8], &i[ 9], &i[10], &i[11],
+			   &i[12], &i[13], &i[14], &i[15],
+			   &pal,
+			   &i[16], &i[17]) != 21) {
+			Error(cip, kDontPerror, "Cannot parse LPSV response: %s\n", rp->msg.first->line);
+			goto done;
+		}
+		if (af != 6 || hal != 16 || pal != 2) {
+			Error(cip, kDontPerror, "Cannot parse LPSV response: %s\n", rp->msg.first->line);
+			goto done;
+		}
+
+		for (j=0, *weird = 0; j<18; j++) {
+			/* Some ftp servers return bogus port octets, such as
+			 * boombox.micro.umn.edu.  Let the caller know if we got a
+			 * weird looking octet.
+			 */
+			if ((i[j] < 0) || (i[j] > 255))
+				*weird = *weird + 1;
+			n[j] = (unsigned char) (i[j] & 0xff);
+		}
+		(void) memcpy(&saddr6->sin6_addr, &n[ 0], (size_t) 16);
+		(void) memcpy(&saddr6->sin6_port, &n[16], (size_t) 2);
+	} else {
+#endif
+		result = RCmd(cip, rp, "PASV");
+		if (result < 0)
+			goto done;
+
+		if (rp->codeType != 2) {
+			/* Didn't understand or didn't want passive port selection. */
+			cip->errNo = result = kErrPASVFailed;
+			goto done;
+		}
 
+		/* The other side returns a specification in the form of
+		 * an internet address as the first four integers (each
+		 * integer stands for 8-bits of the real 32-bit address),
+		 * and two more integers for the port (16-bit port).
+		 *
+		 * It should give us something like:
+		 * "Entering Passive Mode (129,93,33,1,10,187)", so look for
+		 * digits with sscanf() starting 24 characters down the string.
+		 */
+		for (cp = rp->msg.first->line; ; cp++) {
+			if (*cp == '\0') {
+				Error(cip, kDontPerror, "Cannot parse PASV response: %s\n", rp->msg.first->line);
+				goto done;
+			}
+			if (isdigit((int) *cp))
+				break;
+		}
+
+		if (sscanf(cp, "%d,%d,%d,%d,%d,%d",
+			   &i[0], &i[1], &i[2], &i[3], &i[4], &i[5]) != 6) {
+			Error(cip, kDontPerror, "Cannot parse PASV response: %s\n", rp->msg.first->line);
+			goto done;
+		}
+
+		for (j=0, *weird = 0; j<6; j++) {
+			/* Some ftp servers return bogus port octets, such as
+			 * boombox.micro.umn.edu.  Let the caller know if we got a
+			 * weird looking octet.
+			 */
+			if ((i[j] < 0) || (i[j] > 255))
+				*weird = *weird + 1;
+			n[j] = (unsigned char) (i[j] & 0xff);
+		}
+		(void) memcpy(&saddr4->sin_addr, &n[0], (size_t) 4);
+		(void) memcpy(&saddr4->sin_port, &n[4], (size_t) 2);
+#ifdef ENABLE_IPV6
+	}
+#endif
 	result = kNoErr;
 done:
 	DoneWithResponse(cip, rp);
@@ -1008,30 +1223,46 @@
 
 
 static int
-BindToEphemeralPortNumber(int sockfd, struct sockaddr_in *addrp, int ephemLo, int ephemHi)
+BindToEphemeralPortNumber(int sockfd, struct sockaddr *addrp, int ephemLo, int ephemHi)
 {
 	int i;
 	int result;
 	int rangesize;
 	unsigned short port;
 
-	addrp->sin_family = AF_INET;
 	if (((int) ephemLo == 0) || ((int) ephemLo >= (int) ephemHi)) {
 		/* Do it the normal way.  System will
 		 * pick one, typically in the range
 		 * of 1024-4999.
 		 */
-		addrp->sin_port = 0;	/* Let system pick one. */
-
-		result = bind(sockfd, (struct sockaddr *) addrp, sizeof(struct sockaddr_in));
+#ifdef ENABLE_IPV6
+		if (addrp->sa_family == AF_INET6)
+			((struct sockaddr_in6 *)addrp)->sin6_port = 0;	/* Let system pick one. */
+		else
+#endif
+			((struct sockaddr_in *)addrp)->sin_port = 0;	/* Let system pick one. */
+#ifdef HAVE_SOCKADDR_SA_LEN
+		result = bind(sockfd, addrp, addrp->sa_len);
+#else
+		result = bind(sockfd, addrp, SA_LEN(addrp));
+#endif
 	} else {
 		rangesize = (int) ((int) ephemHi - (int) ephemLo);
 		result = 0;
 		for (i=0; i<10; i++) {
 			port = (unsigned short) (((int) rand() % rangesize) + (int) ephemLo);
-			addrp->sin_port = port;
+#ifdef ENABLE_IPV6
+			if (addrp->sa_family == AF_INET6)
+				((struct sockaddr_in6 *)addrp)->sin6_port = port;
+			else
+#endif
+				((struct sockaddr_in *)addrp)->sin_port = port;
 
-			result = bind(sockfd, (struct sockaddr *) addrp, sizeof(struct sockaddr_in));
+#ifdef HAVE_SOCKADDR_SA_LEN
+			result = bind(sockfd, addrp, addrp->sa_len);
+#else
+			result = bind(sockfd, addrp, SA_LEN(addrp));
+#endif
 			if (result == 0)
 				break;
 			if ((errno != 999)
@@ -1066,7 +1297,11 @@
 	result = 0;
 	CloseDataConnection(cip);	/* In case we didn't before... */
 
+#ifdef ENABLE_IPV6
+	dataSocket = socket(cip->ourCtlAddr.ss_family, SOCK_STREAM, 0);
+#else
 	dataSocket = socket(AF_INET, SOCK_STREAM, 0);
+#endif
 	if (dataSocket < 0) {
 		Error(cip, kDoPerror, "Could not get a data socket.\n");
 		result = kErrNewStreamSocket;
@@ -1084,7 +1319,6 @@
 	if ((cip->hasPASV == kCommandNotAvailable) || (mode == kSendPortMode)) {
 tryPort:
 		cip->ourDataAddr = cip->ourCtlAddr;
-		cip->ourDataAddr.sin_family = AF_INET;
 
 #ifdef HAVE_LIBSOCKS
 		cip->ourDataAddr.sin_port = 0;
@@ -1092,7 +1326,7 @@
 			(int) sizeof (cip->ourDataAddr),
 			cip->servCtlAddr.sin_addr.s_addr) < 0) 
 #else
-		if (BindToEphemeralPortNumber(dataSocket, &cip->ourDataAddr, (int) cip->ephemLo, (int) cip->ephemHi) < 0)
+		if (BindToEphemeralPortNumber(dataSocket, (struct sockaddr *)&cip->ourDataAddr, (int) cip->ephemLo, (int) cip->ephemHi) < 0)
 #endif
 		{
 			Error(cip, kDoPerror, "Could not bind the data socket");
@@ -1104,7 +1338,7 @@
 		/* Need to do this so we can figure out which port the system
 		 * gave to us.
 		 */
-		if ((result = GetSocketAddress(cip, dataSocket, &cip->ourDataAddr)) < 0)
+		if ((result = GetSocketAddress(cip, dataSocket, (struct sockaddr *)&cip->ourDataAddr)) < 0)
 			goto bad;
 	
 		if (listen(dataSocket, 1) < 0) {
@@ -1114,7 +1348,7 @@
 			goto bad;
 		}
 	
-		if ((result = SendPort(cip, &cip->ourDataAddr)) < 0)
+		if ((result = SendPort(cip, (struct sockaddr *)&cip->ourDataAddr)) < 0)
 			goto bad;
 	
 		cip->dataPortMode = kSendPortMode;
@@ -1122,11 +1356,9 @@
 		/* Passive mode.  Let the other side decide where to send. */
 		
 		cip->servDataAddr = cip->servCtlAddr;
-		cip->servDataAddr.sin_family = AF_INET;
 		cip->ourDataAddr = cip->ourCtlAddr;
-		cip->ourDataAddr.sin_family = AF_INET;
 
-		if (Passive(cip, &cip->servDataAddr, &weirdPort) < 0) {
+		if (Passive(cip, (struct sockaddr *) &cip->servDataAddr, &weirdPort) < 0) {
 			Error(cip, kDontPerror, "Passive mode refused.\n");
 			cip->hasPASV = kCommandNotAvailable;
 			
@@ -1150,7 +1382,7 @@
 			(int) sizeof (cip->ourDataAddr),
 			cip->servCtlAddr.sin_addr.s_addr) < 0) 
 #else
-		if (BindToEphemeralPortNumber(dataSocket, &cip->ourDataAddr, (int) cip->ephemLo, (int) cip->ephemHi) < 0)
+		if (BindToEphemeralPortNumber(dataSocket, (struct sockaddr *)&cip->ourDataAddr, (int) cip->ephemLo, (int) cip->ephemHi) < 0)
 #endif
 		{
 			Error(cip, kDoPerror, "Could not bind the data socket");
@@ -1158,14 +1390,27 @@
 			cip->errNo = kErrBindDataSocket;
 			goto bad;
 		}
+	
+		/* Need to do this so we can figure out which port the system
+		 * gave to us.
+		 */
+		if ((result = GetSocketAddress(cip, dataSocket, (struct sockaddr *)&cip->ourDataAddr)) < 0)
+			goto bad;
 
 #ifdef NO_SIGNALS
 		result = SConnect(dataSocket, &cip->servDataAddr, (int) cip->connTimeout);
 #else	/* NO_SIGNALS */
 		if (cip->connTimeout > 0)
 			(void) alarm(cip->connTimeout);
-
+#ifdef ENABLE_IPV6
+#ifdef HAVE_SOCKADDR_SA_LEN
+		result = connect(dataSocket, (struct sockaddr *) &cip->servDataAddr, cip->servDataAddr.ss_len);
+#else
+		result = connect(dataSocket, (struct sockaddr *) &cip->servDataAddr, SA_LEN((struct sockaddr*)&cip->servDataAddr));
+#endif
+#else
 		result = connect(dataSocket, (struct sockaddr *) &cip->servDataAddr, (int) sizeof(cip->servDataAddr));
+#endif
 		if (cip->connTimeout > 0)
 			(void) alarm(0);
 #endif	/* NO_SIGNALS */
@@ -1217,7 +1462,7 @@
 		/* Need to do this so we can figure out which port the system
 		 * gave to us.
 		 */
-		if ((result = GetSocketAddress(cip, dataSocket, &cip->ourDataAddr)) < 0)
+		if ((result = GetSocketAddress(cip, dataSocket, (struct sockaddr *) &cip->ourDataAddr)) < 0)
 			goto bad;
 
 		cip->dataPortMode = kPassiveMode;
@@ -1284,23 +1529,54 @@
 		}
 
 		if (cip->require20 != 0) {
-			remoteDataPort = ntohs(cip->servDataAddr.sin_port);
-			remoteCtrlPort = ntohs(cip->servCtlAddr.sin_port);
-			if ((int) remoteDataPort != ((int) remoteCtrlPort - 1)) {
-				Error(cip, kDontPerror, "Data connection did not originate on correct port!\n");
-				(void) closesocket(newSocket);
-				cip->dataSocket = kClosedFileDescriptor;
-				cip->errNo = kErrAcceptDataSocket;
-				return (kErrAcceptDataSocket);
-			} else if (memcmp(&cip->servDataAddr.sin_addr.s_addr, &cip->servCtlAddr.sin_addr.s_addr, sizeof(cip->servDataAddr.sin_addr.s_addr)) != 0) {
-				Error(cip, kDontPerror, "Data connection did not originate from remote server!\n");
-				(void) closesocket(newSocket);
-				cip->dataSocket = kClosedFileDescriptor;
-				cip->errNo = kErrAcceptDataSocket;
-				return (kErrAcceptDataSocket);
+#ifdef ENABLE_IPV6
+			if (cip->servDataAddr.ss_family == AF_INET6) {
+				struct sockaddr_in6 *servDataAddr =
+					(struct sockaddr_in6 *) &cip->servDataAddr;
+				struct sockaddr_in6 *servCtlAddr =
+					(struct sockaddr_in6 *) &cip->servCtlAddr;
+
+				remoteDataPort = ntohs(servDataAddr->sin6_port);
+				remoteCtrlPort = ntohs(servCtlAddr->sin6_port);
+				if ((int) remoteDataPort != ((int) remoteCtrlPort - 1)) {
+					Error(cip, kDontPerror, "Data connection did not originate on correct port!\n");
+					(void) closesocket(newSocket);
+					cip->dataSocket = kClosedFileDescriptor;
+					cip->errNo = kErrAcceptDataSocket;
+					return (kErrAcceptDataSocket);
+				} else if (memcmp(&servDataAddr->sin6_addr, &servCtlAddr->sin6_addr, sizeof(servDataAddr->sin6_addr)) != 0) {
+					Error(cip, kDontPerror, "Data connection did not originate from remote server!\n");
+					(void) close(newSocket);
+					cip->dataSocket = kClosedFileDescriptor;
+					cip->errNo = kErrAcceptDataSocket;
+					return (kErrAcceptDataSocket);
+				}
+			} else {
+#endif
+				struct sockaddr_in *servDataAddr =
+					(struct sockaddr_in *) &cip->servDataAddr;
+				struct sockaddr_in *servCtlAddr =
+					(struct sockaddr_in *) &cip->servCtlAddr;
+
+				remoteDataPort = ntohs(servDataAddr->sin_port);
+				remoteCtrlPort = ntohs(servCtlAddr->sin_port);
+				if ((int) remoteDataPort != ((int) remoteCtrlPort - 1)) {
+					Error(cip, kDontPerror, "Data connection did not originate on correct port!\n");
+					(void) closesocket(newSocket);
+					cip->dataSocket = kClosedFileDescriptor;
+					cip->errNo = kErrAcceptDataSocket;
+					return (kErrAcceptDataSocket);
+				} else if (memcmp(&servDataAddr->sin_addr.s_addr, &servCtlAddr->sin_addr.s_addr, sizeof(servDataAddr->sin_addr.s_addr)) != 0) {
+					Error(cip, kDontPerror, "Data connection did not originate from remote server!\n");
+					(void) close(newSocket);
+					cip->dataSocket = kClosedFileDescriptor;
+					cip->errNo = kErrAcceptDataSocket;
+					return (kErrAcceptDataSocket);
+				}
+#ifdef ENABLE_IPV6
 			}
+#endif		
 		}
-		
 		cip->dataSocket = newSocket;
 	}
 
diff -Nur ncftp-3.0.3.orig/libncftp/ncftp.h ncftp-3.0.3/libncftp/ncftp.h
--- ncftp-3.0.3.orig/libncftp/ncftp.h	Sun Apr 15 05:23:32 2001
+++ ncftp-3.0.3/libncftp/ncftp.h	Tue Jun 19 15:30:33 2001
@@ -178,10 +178,17 @@
 	int mlsFeatures;			/* Do not modify this field. */
 	int STATfileParamWorks;			/* Do not modify this field. */
 	int NLSTfileParamWorks;			/* Do not modify this field. */
+#ifdef ENABLE_IPV6
+	struct sockaddr_storage servCtlAddr;	/* Do not modify this field. */
+	struct sockaddr_storage servDataAddr;	/* Do not modify this field. */
+	struct sockaddr_storage ourCtlAddr;	/* Do not modify this field. */
+	struct sockaddr_storage ourDataAddr;	/* Do not modify this field. */
+#else
 	struct sockaddr_in servCtlAddr;		/* Do not modify this field. */
 	struct sockaddr_in servDataAddr;	/* Do not modify this field. */
 	struct sockaddr_in ourCtlAddr;		/* Do not modify this field. */
 	struct sockaddr_in ourDataAddr;		/* Do not modify this field. */
+#endif
 	int netMode;				/* Do not use or modify. */
 	char *buf;				/* Do not modify this field. */
 	size_t bufSize;				/* Do not modify this field. */
diff -Nur ncftp-3.0.3.orig/ncftp/cmds.c ncftp-3.0.3/ncftp/cmds.c
--- ncftp-3.0.3.orig/ncftp/cmds.c	Sun Apr 15 20:02:37 2001
+++ ncftp-3.0.3/ncftp/cmds.c	Tue Jun 19 15:30:33 2001
@@ -2194,8 +2194,7 @@
 			(void) printf("Unknown host \"%s\".\n", ohost);
 			return (-1);
 		}
-		(void) STRNCPY(gConn.host, ipstr);
-		OpenMsg("Connecting to %s...", ipstr);
+		OpenMsg("Connecting to %s...", gConn.host);
 	} else {
 		OpenMsg("Connecting to %s via %s...", gConn.host, gConn.firewallHost);
 		Trace(0, "Fw: %s  Type: %d  User: %s  Pass: %s  Port: %u\n", 
diff -Nur ncftp-3.0.3.orig/ncftp/util.c ncftp-3.0.3/ncftp/util.c
--- ncftp-3.0.3.orig/ncftp/util.c	Sun Apr 15 19:36:34 2001
+++ ncftp-3.0.3/ncftp/util.c	Tue Jun 19 15:36:29 2001
@@ -845,11 +845,18 @@
 #else
 	int sj;
 	vsigproc_t osigpipe, osigint, osigalrm;
+#ifdef ENABLE_IPV6
+	struct addrinfo hints;
+	struct addrinfo *res;
+	int error;
+#else
 	struct hostent *hp;
+#endif
 #ifndef HAVE_INET_NTOP
 	struct in_addr ina;
 #endif
 
+#ifndef	ENABLE_IPV6
 #ifdef HAVE_INET_ATON
 	if (inet_aton(hn, &ina) != 0) {
 		/* Address is an IP address string, which is what we want. */
@@ -863,6 +870,7 @@
 		return (0);
 	}
 #endif
+#endif
 
 #ifdef HAVE_SIGSETJMP
 	osigpipe = osigint = osigalrm = (sigproc_t) 0;
@@ -887,22 +895,44 @@
 		osigalrm = NcSignal(SIGALRM, CancelGetHostByName);
 		if (t > 0)
 			(void) alarm((unsigned int) t);
+#ifdef ENABLE_IPV6
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_flags = 0;
+		hints.ai_family = PF_UNSPEC;
+		hints.ai_socktype = SOCK_STREAM;
+		hints.ai_protocol = 0;
+		error = getaddrinfo(hn, NULL, &hints, &res);
+#else
 		hp = gethostbyname(hn);
+#endif
 		if (t > 0)
 			(void) alarm(0);
 		(void) NcSignal(SIGPIPE, osigpipe);
 		(void) NcSignal(SIGINT, osigint);
 		(void) NcSignal(SIGALRM, osigalrm);
+#ifdef ENABLE_IPV6
+		if (error == 0) {
+			char buf[NI_MAXHOST];
+
+			getnameinfo(res->ai_addr, res->ai_addrlen,
+				    buf, sizeof(buf),
+				    NULL, 0, NI_NUMERICHOST);
+			(void) Strncpy(dst, buf, dsize);
+			freeaddrinfo(res);
+			return (0);
+		}
+#else
 		if (hp != NULL) {
 #ifdef HAVE_INET_NTOP	/* Mostly to workaround bug in IRIX 6.5's inet_ntoa */
 			(void) memset(dst, 0, dsize);
-			(void) inet_ntop(AF_INET, hp->h_addr_list[0], dst, dsize - 1);
+			(void) inet_ntop(hp->h_addrtype, hp->h_addr_list[0], dst, dsize - 1);
 #else
 			(void) memcpy(&ina.s_addr, hp->h_addr_list[0], (size_t) hp->h_length);
 			(void) Strncpy(dst, inet_ntoa(ina), dsize);
 #endif
 			return (0);
 		}
+#endif
 	}
 #endif	/* !Windows */
 
diff -Nur ncftp-3.0.3.orig/sio/SConnect.c ncftp-3.0.3/sio/SConnect.c
--- ncftp-3.0.3.orig/sio/SConnect.c	Thu Mar 22 03:13:37 2001
+++ ncftp-3.0.3/sio/SConnect.c	Tue Jun 19 15:30:33 2001
@@ -6,7 +6,7 @@
 #endif
 
 int
-SConnect(int sfd, const struct sockaddr_in *const addr, int tlen)
+SConnect(int sfd, const struct sockaddr *const addr, int tlen)
 {
 #ifndef NO_SIGNALS
 	int result;
@@ -24,8 +24,13 @@
 
 	errno = 0;
 	do {
+#ifdef HAVE_SOCKADDR_SA_LEN
 		result = connect(sfd, (struct sockaddr *) addr,
-			(int) sizeof(struct sockaddr_in));
+			(int) addr->sa_len);
+#else
+		result = connect(sfd, (struct sockaddr *) addr,
+			(int) SA_LEN(addr));
+#endif
 	} while ((result < 0) && (errno == EINTR));
 
 	alarm(0);
@@ -48,8 +53,13 @@
 	errno = 0;
 	if (tlen <= 0) {
 		do {
+#ifdef HAVE_SOCKADDR_SA_LEN
+			result = connect(sfd, (struct sockaddr *) addr,
+				(int) addr->sa_len);
+#else
 			result = connect(sfd, (struct sockaddr *) addr,
-				(int) sizeof(struct sockaddr_in));
+				(int) SA_LEN(addr));
+#endif
 			SETERRNO
 		} while ((result < 0) && (errno == EINTR));
 		return (result);
@@ -72,8 +82,13 @@
 #endif
 
 	errno = 0;
+#ifdef HAVE_SOCKADDR_SA_LEN
+	result = connect(sfd, (struct sockaddr *) addr,
+			(int) addr->sa_len);
+#else
 	result = connect(sfd, (struct sockaddr *) addr,
-			(int) sizeof(struct sockaddr_in));
+			(int) SA_LEN(addr));
+#endif
 	if (result == 0) 
 		return 0;	/* Already?!? */
 
diff -Nur ncftp-3.0.3.orig/sio/sio.h ncftp-3.0.3/sio/sio.h
--- ncftp-3.0.3.orig/sio/sio.h	Fri Apr 13 22:05:01 2001
+++ ncftp-3.0.3/sio/sio.h	Tue Jun 19 15:30:33 2001
@@ -163,7 +163,7 @@
 int SClose(int, int);
 
 /* SConnect.c */
-int SConnect(int, const struct sockaddr_in *const, int);
+int SConnect(int, const struct sockaddr *const, int);
 
 /* SConnectByName.c */
 int SConnectByName(int, const char *const, const int);
